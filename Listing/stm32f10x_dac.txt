; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\output\stm32f10x_dac.o --asm_dir=..\Listing\ --list_dir=..\Listing\ --depend=..\output\stm32f10x_dac.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\BSP -I..\CMSIS -I..\Lib\inc -I..\User -I"E:\Program files\keil-arm\ARM\RV31\INC" -I"E:\Program files\keil-arm\ARM\CMSIS\Include" -I"E:\Program files\keil-arm\ARM\Inc\ST\STM32F10x" -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\output\stm32f10x_dac.crf ..\Lib\src\stm32f10x_dac.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  DAC_DeInit PROC
;;;97       */
;;;98     void DAC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;99     {
;;;100      /* Enable DAC reset state */
;;;101      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0748              LSLS     r0,r1,#29
000006  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;102      /* Release DAC from reset state */
;;;103      RCC_APB1PeriphResetCmd(RCC_APB1Periph_DAC, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  f04f5000          MOV      r0,#0x20000000
000010  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;104    }
000014  bd10              POP      {r4,pc}
;;;105    
                          ENDP

                  DAC_Init PROC
;;;116      */
;;;117    void DAC_Init(uint32_t DAC_Channel, DAC_InitTypeDef* DAC_InitStruct)
000016  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119      uint32_t tmpreg1 = 0, tmpreg2 = 0;
000018  2200              MOVS     r2,#0
00001a  2300              MOVS     r3,#0
;;;120      /* Check the DAC parameters */
;;;121      assert_param(IS_DAC_TRIGGER(DAC_InitStruct->DAC_Trigger));
;;;122      assert_param(IS_DAC_GENERATE_WAVE(DAC_InitStruct->DAC_WaveGeneration));
;;;123      assert_param(IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE(DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude));
;;;124      assert_param(IS_DAC_OUTPUT_BUFFER_STATE(DAC_InitStruct->DAC_OutputBuffer));
;;;125    /*---------------------------- DAC CR Configuration --------------------------*/
;;;126      /* Get the DAC CR value */
;;;127      tmpreg1 = DAC->CR;
00001c  4c5a              LDR      r4,|L1.392|
00001e  6822              LDR      r2,[r4,#0]
;;;128      /* Clear BOFFx, TENx, TSELx, WAVEx and MAMPx bits */
;;;129      tmpreg1 &= ~(CR_CLEAR_MASK << DAC_Channel);
000020  f64074fe          MOV      r4,#0xffe
000024  4084              LSLS     r4,r4,r0
000026  43a2              BICS     r2,r2,r4
;;;130      /* Configure for the selected DAC channel: buffer output, trigger, wave generation,
;;;131         mask/amplitude for wave generation */
;;;132      /* Set TSELx and TENx bits according to DAC_Trigger value */
;;;133      /* Set WAVEx bits according to DAC_WaveGeneration value */
;;;134      /* Set MAMPx bits according to DAC_LFSRUnmask_TriangleAmplitude value */ 
;;;135      /* Set BOFFx bit according to DAC_OutputBuffer value */   
;;;136      tmpreg2 = (DAC_InitStruct->DAC_Trigger | DAC_InitStruct->DAC_WaveGeneration |
000028  e9d14500          LDRD     r4,r5,[r1,#0]
00002c  432c              ORRS     r4,r4,r5
00002e  688d              LDR      r5,[r1,#8]
000030  432c              ORRS     r4,r4,r5
000032  68cd              LDR      r5,[r1,#0xc]
000034  ea440305          ORR      r3,r4,r5
;;;137                 DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude | DAC_InitStruct->DAC_OutputBuffer);
;;;138      /* Calculate CR register value depending on DAC_Channel */
;;;139      tmpreg1 |= tmpreg2 << DAC_Channel;
000038  fa03f400          LSL      r4,r3,r0
00003c  4322              ORRS     r2,r2,r4
;;;140      /* Write to DAC CR */
;;;141      DAC->CR = tmpreg1;
00003e  4c52              LDR      r4,|L1.392|
000040  6022              STR      r2,[r4,#0]
;;;142    }
000042  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP

                  DAC_StructInit PROC
;;;149      */
;;;150    void DAC_StructInit(DAC_InitTypeDef* DAC_InitStruct)
000044  2100              MOVS     r1,#0
;;;151    {
;;;152    /*--------------- Reset DAC init structure parameters values -----------------*/
;;;153      /* Initialize the DAC_Trigger member */
;;;154      DAC_InitStruct->DAC_Trigger = DAC_Trigger_None;
000046  6001              STR      r1,[r0,#0]
;;;155      /* Initialize the DAC_WaveGeneration member */
;;;156      DAC_InitStruct->DAC_WaveGeneration = DAC_WaveGeneration_None;
000048  6041              STR      r1,[r0,#4]
;;;157      /* Initialize the DAC_LFSRUnmask_TriangleAmplitude member */
;;;158      DAC_InitStruct->DAC_LFSRUnmask_TriangleAmplitude = DAC_LFSRUnmask_Bit0;
00004a  6081              STR      r1,[r0,#8]
;;;159      /* Initialize the DAC_OutputBuffer member */
;;;160      DAC_InitStruct->DAC_OutputBuffer = DAC_OutputBuffer_Enable;
00004c  60c1              STR      r1,[r0,#0xc]
;;;161    }
00004e  4770              BX       lr
;;;162    
                          ENDP

                  DAC_Cmd PROC
;;;172      */
;;;173    void DAC_Cmd(uint32_t DAC_Channel, FunctionalState NewState)
000050  b139              CBZ      r1,|L1.98|
;;;174    {
;;;175      /* Check the parameters */
;;;176      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;177      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;178      if (NewState != DISABLE)
;;;179      {
;;;180        /* Enable the selected DAC channel */
;;;181        DAC->CR |= (DAC_CR_EN1 << DAC_Channel);
000052  4a4d              LDR      r2,|L1.392|
000054  6812              LDR      r2,[r2,#0]
000056  2301              MOVS     r3,#1
000058  4083              LSLS     r3,r3,r0
00005a  431a              ORRS     r2,r2,r3
00005c  4b4a              LDR      r3,|L1.392|
00005e  601a              STR      r2,[r3,#0]
000060  e006              B        |L1.112|
                  |L1.98|
;;;182      }
;;;183      else
;;;184      {
;;;185        /* Disable the selected DAC channel */
;;;186        DAC->CR &= ~(DAC_CR_EN1 << DAC_Channel);
000062  4a49              LDR      r2,|L1.392|
000064  6812              LDR      r2,[r2,#0]
000066  2301              MOVS     r3,#1
000068  4083              LSLS     r3,r3,r0
00006a  439a              BICS     r2,r2,r3
00006c  4b46              LDR      r3,|L1.392|
00006e  601a              STR      r2,[r3,#0]
                  |L1.112|
;;;187      }
;;;188    }
000070  4770              BX       lr
;;;189    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
                          ENDP

                  DAC_DMACmd PROC
;;;232      */
;;;233    void DAC_DMACmd(uint32_t DAC_Channel, FunctionalState NewState)
000072  b141              CBZ      r1,|L1.134|
;;;234    {
;;;235      /* Check the parameters */
;;;236      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;237      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;238      if (NewState != DISABLE)
;;;239      {
;;;240        /* Enable the selected DAC channel DMA request */
;;;241        DAC->CR |= (DAC_CR_DMAEN1 << DAC_Channel);
000074  4a44              LDR      r2,|L1.392|
000076  6812              LDR      r2,[r2,#0]
000078  f44f5380          MOV      r3,#0x1000
00007c  4083              LSLS     r3,r3,r0
00007e  431a              ORRS     r2,r2,r3
000080  4b41              LDR      r3,|L1.392|
000082  601a              STR      r2,[r3,#0]
000084  e007              B        |L1.150|
                  |L1.134|
;;;242      }
;;;243      else
;;;244      {
;;;245        /* Disable the selected DAC channel DMA request */
;;;246        DAC->CR &= ~(DAC_CR_DMAEN1 << DAC_Channel);
000086  4a40              LDR      r2,|L1.392|
000088  6812              LDR      r2,[r2,#0]
00008a  f44f5380          MOV      r3,#0x1000
00008e  4083              LSLS     r3,r3,r0
000090  439a              BICS     r2,r2,r3
000092  4b3d              LDR      r3,|L1.392|
000094  601a              STR      r2,[r3,#0]
                  |L1.150|
;;;247      }
;;;248    }
000096  4770              BX       lr
;;;249    
                          ENDP

                  DAC_SoftwareTriggerCmd PROC
;;;259      */
;;;260    void DAC_SoftwareTriggerCmd(uint32_t DAC_Channel, FunctionalState NewState)
000098  b510              PUSH     {r4,lr}
;;;261    {
;;;262      /* Check the parameters */
;;;263      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;264      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;265      if (NewState != DISABLE)
00009a  b151              CBZ      r1,|L1.178|
;;;266      {
;;;267        /* Enable software trigger for the selected DAC channel */
;;;268        DAC->SWTRIGR |= (uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4);
00009c  4a3a              LDR      r2,|L1.392|
00009e  1d12              ADDS     r2,r2,#4
0000a0  6812              LDR      r2,[r2,#0]
0000a2  0904              LSRS     r4,r0,#4
0000a4  2301              MOVS     r3,#1
0000a6  40a3              LSLS     r3,r3,r4
0000a8  431a              ORRS     r2,r2,r3
0000aa  4b37              LDR      r3,|L1.392|
0000ac  1d1b              ADDS     r3,r3,#4
0000ae  601a              STR      r2,[r3,#0]
0000b0  e009              B        |L1.198|
                  |L1.178|
;;;269      }
;;;270      else
;;;271      {
;;;272        /* Disable software trigger for the selected DAC channel */
;;;273        DAC->SWTRIGR &= ~((uint32_t)DAC_SWTRIGR_SWTRIG1 << (DAC_Channel >> 4));
0000b2  4a35              LDR      r2,|L1.392|
0000b4  1d12              ADDS     r2,r2,#4
0000b6  6812              LDR      r2,[r2,#0]
0000b8  0904              LSRS     r4,r0,#4
0000ba  2301              MOVS     r3,#1
0000bc  40a3              LSLS     r3,r3,r4
0000be  439a              BICS     r2,r2,r3
0000c0  4b31              LDR      r3,|L1.392|
0000c2  1d1b              ADDS     r3,r3,#4
0000c4  601a              STR      r2,[r3,#0]
                  |L1.198|
;;;274      }
;;;275    }
0000c6  bd10              POP      {r4,pc}
;;;276    
                          ENDP

                  DAC_DualSoftwareTriggerCmd PROC
;;;283      */
;;;284    void DAC_DualSoftwareTriggerCmd(FunctionalState NewState)
0000c8  b140              CBZ      r0,|L1.220|
;;;285    {
;;;286      /* Check the parameters */
;;;287      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;288      if (NewState != DISABLE)
;;;289      {
;;;290        /* Enable software trigger for both DAC channels */
;;;291        DAC->SWTRIGR |= DUAL_SWTRIG_SET ;
0000ca  492f              LDR      r1,|L1.392|
0000cc  1d09              ADDS     r1,r1,#4
0000ce  6809              LDR      r1,[r1,#0]
0000d0  f0410103          ORR      r1,r1,#3
0000d4  4a2c              LDR      r2,|L1.392|
0000d6  1d12              ADDS     r2,r2,#4
0000d8  6011              STR      r1,[r2,#0]
0000da  e007              B        |L1.236|
                  |L1.220|
;;;292      }
;;;293      else
;;;294      {
;;;295        /* Disable software trigger for both DAC channels */
;;;296        DAC->SWTRIGR &= DUAL_SWTRIG_RESET;
0000dc  492a              LDR      r1,|L1.392|
0000de  1d09              ADDS     r1,r1,#4
0000e0  6809              LDR      r1,[r1,#0]
0000e2  f0210103          BIC      r1,r1,#3
0000e6  4a28              LDR      r2,|L1.392|
0000e8  1d12              ADDS     r2,r2,#4
0000ea  6011              STR      r1,[r2,#0]
                  |L1.236|
;;;297      }
;;;298    }
0000ec  4770              BX       lr
;;;299    
                          ENDP

                  DAC_WaveGenerationCmd PROC
;;;313      */
;;;314    void DAC_WaveGenerationCmd(uint32_t DAC_Channel, uint32_t DAC_Wave, FunctionalState NewState)
0000ee  b510              PUSH     {r4,lr}
;;;315    {
;;;316      /* Check the parameters */
;;;317      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;318      assert_param(IS_DAC_WAVE(DAC_Wave)); 
;;;319      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;320      if (NewState != DISABLE)
0000f0  b13a              CBZ      r2,|L1.258|
;;;321      {
;;;322        /* Enable the selected wave generation for the selected DAC channel */
;;;323        DAC->CR |= DAC_Wave << DAC_Channel;
0000f2  4b25              LDR      r3,|L1.392|
0000f4  681b              LDR      r3,[r3,#0]
0000f6  fa01f400          LSL      r4,r1,r0
0000fa  4323              ORRS     r3,r3,r4
0000fc  4c22              LDR      r4,|L1.392|
0000fe  6023              STR      r3,[r4,#0]
000100  e006              B        |L1.272|
                  |L1.258|
;;;324      }
;;;325      else
;;;326      {
;;;327        /* Disable the selected wave generation for the selected DAC channel */
;;;328        DAC->CR &= ~(DAC_Wave << DAC_Channel);
000102  4b21              LDR      r3,|L1.392|
000104  681b              LDR      r3,[r3,#0]
000106  fa01f400          LSL      r4,r1,r0
00010a  43a3              BICS     r3,r3,r4
00010c  4c1e              LDR      r4,|L1.392|
00010e  6023              STR      r3,[r4,#0]
                  |L1.272|
;;;329      }
;;;330    }
000110  bd10              POP      {r4,pc}
;;;331    
                          ENDP

                  DAC_SetChannel1Data PROC
;;;341      */
;;;342    void DAC_SetChannel1Data(uint32_t DAC_Align, uint16_t Data)
000112  b508              PUSH     {r3,lr}
;;;343    {  
;;;344      __IO uint32_t tmp = 0;
000114  2200              MOVS     r2,#0
000116  9200              STR      r2,[sp,#0]
;;;345      
;;;346      /* Check the parameters */
;;;347      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;348      assert_param(IS_DAC_DATA(Data));
;;;349      
;;;350      tmp = (uint32_t)DAC_BASE; 
000118  4a1b              LDR      r2,|L1.392|
00011a  9200              STR      r2,[sp,#0]
;;;351      tmp += DHR12R1_OFFSET + DAC_Align;
00011c  f1000208          ADD      r2,r0,#8
000120  9b00              LDR      r3,[sp,#0]
000122  441a              ADD      r2,r2,r3
000124  9200              STR      r2,[sp,#0]
;;;352    
;;;353      /* Set the DAC channel1 selected data holding register */
;;;354      *(__IO uint32_t *) tmp = Data;
000126  9a00              LDR      r2,[sp,#0]
000128  6011              STR      r1,[r2,#0]
;;;355    }
00012a  bd08              POP      {r3,pc}
;;;356    
                          ENDP

                  DAC_SetChannel2Data PROC
;;;366      */
;;;367    void DAC_SetChannel2Data(uint32_t DAC_Align, uint16_t Data)
00012c  b508              PUSH     {r3,lr}
;;;368    {
;;;369      __IO uint32_t tmp = 0;
00012e  2200              MOVS     r2,#0
000130  9200              STR      r2,[sp,#0]
;;;370    
;;;371      /* Check the parameters */
;;;372      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;373      assert_param(IS_DAC_DATA(Data));
;;;374      
;;;375      tmp = (uint32_t)DAC_BASE;
000132  4a15              LDR      r2,|L1.392|
000134  9200              STR      r2,[sp,#0]
;;;376      tmp += DHR12R2_OFFSET + DAC_Align;
000136  f1000214          ADD      r2,r0,#0x14
00013a  9b00              LDR      r3,[sp,#0]
00013c  441a              ADD      r2,r2,r3
00013e  9200              STR      r2,[sp,#0]
;;;377    
;;;378      /* Set the DAC channel2 selected data holding register */
;;;379      *(__IO uint32_t *)tmp = Data;
000140  9a00              LDR      r2,[sp,#0]
000142  6011              STR      r1,[r2,#0]
;;;380    }
000144  bd08              POP      {r3,pc}
;;;381    
                          ENDP

                  DAC_SetDualChannelData PROC
;;;395      */
;;;396    void DAC_SetDualChannelData(uint32_t DAC_Align, uint16_t Data2, uint16_t Data1)
000146  b530              PUSH     {r4,r5,lr}
;;;397    {
;;;398      uint32_t data = 0, tmp = 0;
000148  2400              MOVS     r4,#0
00014a  2300              MOVS     r3,#0
;;;399      
;;;400      /* Check the parameters */
;;;401      assert_param(IS_DAC_ALIGN(DAC_Align));
;;;402      assert_param(IS_DAC_DATA(Data1));
;;;403      assert_param(IS_DAC_DATA(Data2));
;;;404      
;;;405      /* Calculate and set dual DAC data holding register value */
;;;406      if (DAC_Align == DAC_Align_8b_R)
00014c  2808              CMP      r0,#8
00014e  d102              BNE      |L1.342|
;;;407      {
;;;408        data = ((uint32_t)Data2 << 8) | Data1; 
000150  ea422401          ORR      r4,r2,r1,LSL #8
000154  e001              B        |L1.346|
                  |L1.342|
;;;409      }
;;;410      else
;;;411      {
;;;412        data = ((uint32_t)Data2 << 16) | Data1;
000156  ea424401          ORR      r4,r2,r1,LSL #16
                  |L1.346|
;;;413      }
;;;414      
;;;415      tmp = (uint32_t)DAC_BASE;
00015a  4b0b              LDR      r3,|L1.392|
;;;416      tmp += DHR12RD_OFFSET + DAC_Align;
00015c  f1000520          ADD      r5,r0,#0x20
000160  442b              ADD      r3,r3,r5
;;;417    
;;;418      /* Set the dual DAC selected data holding register */
;;;419      *(__IO uint32_t *)tmp = data;
000162  601c              STR      r4,[r3,#0]
;;;420    }
000164  bd30              POP      {r4,r5,pc}
;;;421    
                          ENDP

                  DAC_GetDataOutputValue PROC
;;;429      */
;;;430    uint16_t DAC_GetDataOutputValue(uint32_t DAC_Channel)
000166  b508              PUSH     {r3,lr}
;;;431    {
000168  4601              MOV      r1,r0
;;;432      __IO uint32_t tmp = 0;
00016a  2000              MOVS     r0,#0
00016c  9000              STR      r0,[sp,#0]
;;;433      
;;;434      /* Check the parameters */
;;;435      assert_param(IS_DAC_CHANNEL(DAC_Channel));
;;;436      
;;;437      tmp = (uint32_t) DAC_BASE ;
00016e  4806              LDR      r0,|L1.392|
000170  9000              STR      r0,[sp,#0]
;;;438      tmp += DOR_OFFSET + ((uint32_t)DAC_Channel >> 2);
000172  202c              MOVS     r0,#0x2c
000174  eb000091          ADD      r0,r0,r1,LSR #2
000178  9a00              LDR      r2,[sp,#0]
00017a  4410              ADD      r0,r0,r2
00017c  9000              STR      r0,[sp,#0]
;;;439      
;;;440      /* Returns the DAC channel data output register value */
;;;441      return (uint16_t) (*(__IO uint32_t*) tmp);
00017e  9800              LDR      r0,[sp,#0]
000180  6800              LDR      r0,[r0,#0]
000182  b280              UXTH     r0,r0
;;;442    }
000184  bd08              POP      {r3,pc}
;;;443    
                          ENDP

000186  0000              DCW      0x0000
                  |L1.392|
                          DCD      0x40007400
